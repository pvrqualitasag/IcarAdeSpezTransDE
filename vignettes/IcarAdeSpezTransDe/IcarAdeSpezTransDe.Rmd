---
output:
  pdf_document:
    includes:
      in_header: tex/header.tex
    keep_tex: yes
    fig_caption: false
  word_document: default
---

```{r DocumentSetup, echo=FALSE, results='hide', include=FALSE}
### # specify knitr options
knitr::opts_chunk$set(echo = FALSE, results = 'asis')

### # initialize section counter
robjSecEnum <- rqudocuhelper::SectionEnumerator$new()
```


![Qualitas Logo](png/QualitasLogo.png)

\fcolorbox{black}{white}{
	\parbox[t]{1.0\linewidth}{
		\centering \fontsize{12pt}{20pt}\selectfont % 
		\vspace*{0.5cm} % 

		\hfill Übersetzung Spezifikation

		\vspace*{0.5cm} 
	}
}

\vspace*{0.5cm}

\fcolorbox{black}{white}{
	\parbox[t]{1.0\linewidth}{
		\centering \fontsize{25pt}{40pt}\selectfont %
		\vspace*{0.7cm}
    ICAR Spezifikation       \\
    Automatisierter Austausch\\
    von Tierdaten    \\

		\vspace*{0.7cm} % Space between the end of the title and the bottom of the grey box
	}
}

\vspace*{1cm}

\begin{center}
\includegraphics[width=0.5\textwidth]{png/Pedigree.png}
\end{center}

\vspace{5ex}
{\centering \small
\hfill
\begin{tabular}{l}
Peter von Rohr                      \\
FB EDV, Qualitas AG                 \\
\verb+http://www.qualitasag.ch+     \\
\verb+peter.vonrohr@qualitasag.ch+  
\end{tabular}
}

\pagebreak

\tableofcontents

\pagebreak


```{r R6DocuStatus}
### # change to new package
r6objDocStat <- rmddochelper::R6ClassDocuStatus$new()
r6objDocStat$setProject("ICAR-ADE-SpUe")
# r6objDocStat$setStatus("Erweiterung Kap 4.2 Datenaustausch")
# r6objDocStat$setVersion("0.0.910")
# r6objDocStat$setDate("05.07.2016")

# r6objDocStat$setStatus("Servicebeschreigung: GetHerdList")
# r6objDocStat$setVersion("0.0.911")
# r6objDocStat$setDate("06.07.2016")

r6objDocStat$setStatus("Servicebeschreigung: UpdateAnimal")
r6objDocStat$setVersion("0.0.912")
r6objDocStat$setDate("07.07.2016")
### # include the table
r6objDocStat$include_doc_stat(psTitle = "# Dokumentenstatus")
```

\pagebreak

# Abkürzungen

```{r AbrTable}
robjAbrTable <- rqudocuhelper::refObjTable$new()
pvecTableHeader <- c("Abkürzung",
                     "Bedeutung")
robjAbrTable$setTableHeader(psTableHeader = pvecTableHeader)
robjAbrTable$addRow(plTableRow = list(Abr = "ICAR",
                                      What = "International Committee for Animal Recording"))
robjAbrTable$addRow(plTableRow = list(Abr = "ADE",
                                      What = "Animal Data Exchange"))
robjAbrTable$addRow(plTableRow = list(Abr = "W3C",
                                      What = "World Wide Web Consortium"))
robjAbrTable$addRow(plTableRow = list(Abr = "UNCEFACT",
                                      What = "United Nations Center for Trade Fascilitation and Electronic Business"))
robjAbrTable$addRow(plTableRow = list(Abr = "ISO",
                                      What = "International Organization for Standardization"))
robjAbrTable$addRow(plTableRow = list(Abr = "SOAP",
                                      What = "Simple Object Access Protocol"))
robjAbrTable$addRow(plTableRow = list(Abr = "REST",
                                      What = "Representational state transfer"))
robjAbrTable$addRow(plTableRow = list(Abr = "ATDA",
                                      What = "automatisierter Tierdatenaustausch"))
robjAbrTable$addRow(plTableRow = list(Abr = "XML",
                                      What = "eXtenible Markup Language"))
robjAbrTable$addRow(plTableRow = list(Abr = "XSD",
                                      What = "XML Schema Definition"))
robjAbrTable$addRow(plTableRow = list(Abr = "WSDL",
                                      What = "Web Services Description Language"))
robjAbrTable$addRow(plTableRow = list(Abr = "ADIS",
                                      What = "Agricultural Data Interchange Syntax"))
robjAbrTable$addRow(plTableRow = list(Abr = "ADED",
                                      What = "Agricultural Data Element Dictionary"))
robjAbrTable$addRow(plTableRow = list(Abr = "HTTP",
                                      What = "Hypertext Transfer Protocol"))
robjAbrTable$addRow(plTableRow = list(Abr = "JSON",
                                      What = "JavaScript Object Notation"))
robjAbrTable$addRow(plTableRow = list(Abr = "URL",
                                      What = "Unified Resource Locator (Adresse einer Webseite), kann auch als URI (Unified Resource Identifier) bezeichnet"))
#robjAbrTable$addRow(plTableRow = list(Abr = "",
#                                      What = ""))
robjAbrTable$to_pander_pandoc(psStyle = "grid",
                              psJustify = rep("left", length(pvecTableHeader)),
                              pnSplitCells = c(20,60))
```


\pagebreak

# Erklärungen
Dieses Dokument basiert auf Version 1.8 (Final release vom 20.11.2015) der ICAR Spezifikation ``Animal Data Exchange''. Technische Fachbegriffe wurden sinngemäss übersetzt und mit dem englischen Begriff in Klammern versehen. Diagramme wurden per Screen-shots aus dem Originaldokument kopiert und mit Zusatzinformation in Deutsch versehen. Ergänzende Bemerkungen des Übersetzers sind mit geschweiften Klammern {} gekennzeichnet.


\vspace{1ex}
```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("# Ausgangslage")
```
ICAR ADE steht für die Spezifikation des automatisierten Austauschs von Tierdaten von ICAR. Der Datenaustausch wird anhand von folgenden Bestandteilen definiert.

1. Anforderungen (Business requirements) und technischen Spezifikationen
2. Datenbeschreibung zur Verfügung gestellt als Dateien, welche konsistent sind mit den Empfehlungen von W3C für XML Schemas, UNCEFACT und ISO
3. Spezifikationen von Interfaces zur Verfügung gestellt als Dateien, konsistent mit den Empfehlungen von W3C für XML Schemas, UNCEFACT und ISO

Die Anforderungen können unterteilt werden in 

- allgemeine Anforderungen, welche für jede Art von Datenaustausch zutreffen
- spezifische Anforderungen je nach Art des Datenaustauschs
- Datenbeschreibungen

Für einen bestimmten Datenaustausch enthalten die spezifischen Anforderungen 

- den Zweck des Datenaustauschs
- den Kontext (business context) des Datenaustauschs
- die Anforderungen an den Datenaustausch inklusive der Beschreibung des Übermittlungsprotokolls

Datenbeschriftungen beinhalten

- Beschreibung des Services
- Aufbau des Übermittlungsprotokolls
- Beschreibung der Datenentität (entity)
- Beschreibung einer Datenuntereinheit (item)
- Beschreibung des Code-sets, d.h. der Zeichencodierung

Die technische Implementation behandelt die Umsetzung der Anforderungen auf verschiedene Arten

- Vordergründig sollen die Empfehlungen von W3C und UNCEFACT für Datendefinitionen und Interfacedefinitionen (SOAP) verwendet werden.
- Alternativ können auch ISO Standards (17532 2007) für den Datenaustausch ab Hof mit stationärer Ausrüstung und REST Technologie verwendet werden.

{Eine Übersicht der verschiedenen Komponenten ist im folgenden Diagramm gegeben.

```{r echo=FALSE, results='asis'}
rqudocuhelper::insertOdgAsPdf(psOdgFileStem = "DiagrammSpezScope")
```
}

\pagebreak

```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("# Beschreibung des automatisierten Tierdatenaustauschs")
```
{Dieser Abschnitt enthält folgende Punkte

- Geschichte und aktueller Status betreffend des ATDA
- Ziele des ATDA
- Strategie zur Erreichung der Ziele des ATDA
- Kontext des ATDA

In den folgenden Unterabschnitten werden die einzelnen Punkte noch genauer beschrieben.}

```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("## Hintergrund (Background)")
```
Aktuell ist der ATDA zwischen Geräten und externen Informationssystem nicht möglich oder nur über spezialisierte Softwareprogramme (sogenannte Middleware) möglich. Diese Middleware basiert auf lokalen meist proprietären und veralteten Standards. Das folgende Diagramm zeigt die aktuelle Situation bezüglich ATDA

```{r echo=FALSE, results='asis'}
rqudocuhelper::insertOdgAsPdf(psOdgFileStem = "OrgSpezDiagramm1")
```

Die Middleware ist teuer in der Implementation und im Unterhalt. Meistens müssen diese Systeme mit manuellen Interventionen bedient werden. Diese Middleware basierten Systeme sind häufig langsam und sind sehr aufwändig zu optimieren. Daraus folgt auch, dass die Übermittlung von grossen Datenmengen nicht möglich ist.

Moderne Datenzentren machen es möglich grosse Datenmengen zu verarbeiten. Eine steigende Anzahl an Gerätschaften und Sensoren produziert eine exponentiell wachsende Menge and Daten. Diese enormen Datenmengen können nur noch durch automatisierte und standardisierte Prozesse verarbeitet werden. 

Eines automatisierter Austausch von grossen Datenmengen in Echtzeit hätte die folgenden Vorteile:

1. Neue Merkmale für die Selektion in Nutztierpopulationen
2. Verbesserung der Tierüberwachung durch die Zusammenfassung von Daten von verschiedenen Quellen, wie zum Beispiel  Geräte, Labors, ...
3. Verbesserung der Kalibrierung von Geräten zur Verbesserung der Messgenauigkeit

```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("## Ziele des Tierdatenaustauschs")
```
Das primäre Ziel ist die Etablierung eines direkten, permanenten zuverlässigen Services zum Austausch von grossen Datenmengen zwischen Geräten und externen Informationssystemen. Der Service soll folgende Eigenschaften aufweisen: 

- einfach zu implementieren
- einfach zu betreuen
- Kosten-effizient
- in beiden Richtungen zwischen Gerät und Informationssystem funktionieren

```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("## Strategien zur Erreichung der Ziele")
```

```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("### Inhalt des ATDA")
```

Die Ziele des ATDA können durch ein Framework mit folgenden Bestandteilen oder Eigenschaften erreicht werden  

1. Architektur zur Unterstützung des Datenaustauschs
2. Standards für Nachrichten und Daten
3. Tools zur Erleichterung der Umsetzung (Implementation)
4. Reaktiver Unterhaltsprozess

Die vorgeschlagene Architektur basiert auf einem Service-orientierten Ansatz, in welchem das externe Informationssystem als Provider dem Gerät als Client verschiedene Services zur Verfügung stellt. Das folgende Diagramm zeigt die vorgeschlagene Modellarchitektur

```{r echo=FALSE, results='asis'}
rqudocuhelper::insertOdgAsPdf(psOdgFileStem = "OrgSpezDiagramm2")
```

Die im obigen Diagramm gezeigte Architektur kann durch verschiedene Informationstechnologien implementiert werden. Diese Technologie-Standards sind in diesem Dokument beschrieben. Diese Standards beinhalten

- Anforderungen und Voraussetzungen zur Verwendung des Services
- Voraussetzungen zur Bereitstellung des Services
- Voraussetzungen für den Datenaustausch
- Semantische Definition der ausgetauschten Daten, d.h. die Bedeutung der Daten, inklusive der Zeichenkodierung (code set). {Die Semantik der Daten bezeichnet die Zuweisung von Bedeutungen zu den Daten}
- Spezifikation der Syntax für die ausgetauschten Daten nach Standards von W3C, UNCEFACT und ISO. {Dies betrifft das zugelassene Format der Daten}
- Spezifikation eines Interfaces nach den Standards von W3C, UNCEFACT und ISO. {Das Interface bezeichnet die Menge an Funktionalitäten, welche als Kunden (Clients) des Services aufgerufen werden können}

Die Tools, welche die Umsetzung vereinfachen sollen, beinhalten

- eine Webseite zum Download von
    + Dateien mit XML Datentypen (XSD Dateien)
    + Dateien zur Spezifikation des web service (WSDL Dateien)
- eine Testplatform

{Aufgrund der Email von Bert van 't Land vom 13.05.2016 ist diese Webseite unter: \url{https://icar-web.atlassian.net/wiki/display/ADE/ICAR+ADE+public+information} erreichbar. Von dort können ohne Login die Spezifikation und die WSDL-Dateien heruntergeladen werden.}


```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("### ADE Implementation")
```

Das nachfolgende Diagramm beschreibt den Prozess des Datenaustauschs

```{r echo=FALSE, results='asis'}
rqudocuhelper::insertOdgAsPdf(psOdgFileStem = "OrgSpezDiagramm3", pnPaperWidthScale = 0.5)
```

Der oben beschriebene Prozess wird durch eine Nachfrage (business need) ausgelöst. Die Anforderungen (business requirements) sollen das Resultat einer Zusammenarbeit zwischen ICAR und Gerätehersteller sein. Diese sind unabhängig von der Technik oder Technologie, welche zur Umsetzung verwendet wird. {wahrscheinlich sind hier die Anforderungen gemeint}

Zwei Arten der Umsetzung werden hier berücksichtigt

1. W3C und UNCEFACT Standards, als bevorzugte Lösung
2. ISO (17532 2007) / REST, oder andere Alternativen

Die W3C Implementierung besteht aus

1. Technische Beschreibung eines Datenelementes als XSD Datei basierend auf UNCEFACT Datentypen
2. Spezifikation des Interfaces als WSDL Datei
3. Basierend auf der WSDL
    + Umsetzung des Clients durch den Gerätehersteller
    + Umsetzung des Servers durch den Betreiber des Datencenters


```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("## Kontext (Business Context)")
```
{In diesem Abschnitt werden die im Schema verwendeten Begriffe definiert.}

Das nachfolgende Diagramm beschreibt den Kontext

```{r echo=FALSE, results='asis'}
rqudocuhelper::insertOdgAsPdf(psOdgFileStem = "OrgSpezDiagramm4")
```


{**Begriff: Dienstleister (Service Provider)**}

Organisationen {im Diagramm mit ``Service Providers'' bezeichnet und im folgenden mit Dienstleister übersetzt} stellen den Besitzern der Melkgeräte verschiedene Dienste (Services) zur Verfügung. Der Zweck dieser Dienste ist

- Registrierung der Daten in einer Datenbank
- aggregierte Informationen {basierend auf den Daten} zurückzugeben

``Organisationen'' können Organisationen zur Aufzeichnung von Milchdaten, Zuchtorganisationen und andere Datenbankdienstleister sein.

+-------------------------------------------------------------------------------------------------------+
|  Für den Rest dieses Dokuments werden diese Organisationen als ``Dienstleister'' (Service provider)   |
|  bezeichnet.                                                                                          |
+-------------------------------------------------------------------------------------------------------+

Der Eigentümer der Melkausrüstung und der Dienstleister müssen folgendes aushandeln

- Bedingungen zur Benützung der verfügbaren Dienste
- benötigte Parameter für den Datenaustausch

Diese Punkte müssen vertraglich geregelt werden.

{**Begriff: Melkausrüstung (milking equipment)**}

Die Melkausrüstung besteht aus einer Sammlung von Hardware-Komponenten und aus Softwareprogrammen, welche mindestens folgende Funktionen umfassen:

1. Messung der Milchmenge und von anderen Milchparametern (characteristic) {Hier ist nicht klar, was gemeint ist}
2. Abfüllen von Milchprobenfläschchen und Registrierung der Verbindung zwischen Fläschchen und Tier
3. Abspeichern der Melkresultate
4. Verbinden zu, senden an und empfangen von Daten von externen Informationssystemen

Die Melkausrüstung kann noch andere Funktionalitäten haben, welche von ATDA unabhängig sind. Melksysteme können als verschiedene Gerätetypen wie Roboter, elektronische Milchmesssystem, ... vorkommen. {Diese Aussage steht sehr isoliert da und mir ist nicht klar, was damit gemeint ist.}

+-------------------------------------------------------------------------------------------------------+
|  Für den Rest dieses Dokuments werden Melksysteme als ``Ausrüstung'' (Equipment) bezeichnet.          |
+-------------------------------------------------------------------------------------------------------+

{**Begriff: Melker / Melkoperator (milking operator)**}

Die Melkausrüstung wird durch einen Melker bedient und überwacht. 

+-------------------------------------------------------------------------------------------------------+
|  Für den Rest dieses Dokuments wird der Melker (Melkoperator) als ``Operator'' bezeichnet.              |
+-------------------------------------------------------------------------------------------------------+

Der Operator ist angestellt und abhängig vom Besitzer der Melkausrüstung. Der Operator hat Berechtigung zum Ausführen folgender Tätigkeiten

- Versorgung der Melkausrüstung mit Parametern für den Datenaustausch und für Milchproben {Parameter der Milchproben ist hier nicht genau umschrieben}
- Installation und Entfernen der Milchfläschchen für die Milchproben
- Versand von Milchprobem an Analyselabors

Verschiedene Personen können die Rolle des Operators übernehmen, so zum Beispiel Bauern, Angestellte auf Bauernhöfen, Techniker von Dienstleistern.

{**Begriff: Informationssystem (information system)**}

Der Dienstleister betreibt ein Informationssystem, welches die Dienste anbietet. Das Informationssystem besteht aus Servern, Datenbanken und Softwareprogrammen, welche nicht Teil der Melkausrüstung sind. Das Informationssystem ist über eine Netzwerkverbindung zur Melkausrüstung verbunden. Das Informationssystem hat minimal folgende Funktionen: 

1. Empfang und Verarbeitung von Anfragen des Melksystems
2. Aktualisierung der Datenbank mit den Informationen des Melksystems
3. Lieferung der Resultate des Milchanalyselabors, welches die vom anfragenden Melksystem gesammelten Proben analysiert hat

Das Informationssystem vom Dienstleister kann andere Funktionen unabhängig von ATDA erfüllen.

+-------------------------------------------------------------------------------------------------------+
|  Für den Rest dieses Dokuments wird das Informationssystem des Dienstleisters als                     | 
|  ``Informationssystem'' bezeichnet.                                                                   |
+-------------------------------------------------------------------------------------------------------+


```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("# Generelle Spezifikation")
robjSecEnum$displayNumSection("## Generelle Spezifikationen des Datentransports")
robjSecEnum$displayNumSection("### SOAP/XML Web Services")
```
Für den Datentransport wurde der Standard SOAP/XML Version 1.2 nach W3C gewählt. Eine Beschreibung dieses Standards ist unter http://www.w3.org/TR/2007/REC-soap12-part0-20070427/ verfügbar. Da für den Design-Prozess ein ``top-down'' Ansatz gewählt wurde, hat ICAR ADE schon Dateien mit WSDL und XSD Dateien vorgegeben, welche schon eine komplettes Set an Definitionen für den Datenaustausch bilden. Basierend auf diesen Definitionen können SOAP-Webservices erstellt werden. Die meisten modernen Programmiersprachen (wie Java, .NET {dies sollte wahrscheinlich C# heissen, weil .NET ist keine Programmiersprache für sich}) bieten Tools an, welche die Erstellung von Interface-Klassen zur Verbindung zwischen Datentransport-Layer und Prozess-Layer vereinfachen.

Bei jeder Veröffentlichung einer neuen Version der ICAR ADE Spezifikationen wird ein Set von WSDL/XSD Dateien zum Download von der ICAR Webseite angeboten.

Die WSDL/XSD Dateien beschreiben folgende Aspekte des Transport-Protokolls

- Endpunkte des Services {Sind hier Dienstanbieter und Client gemeint?}
- Eingabe und Ausgabe Nachrichten
- Grundlegende Definitionen von Datentypen (XSD Typen, UNCEFACT Typen, ...)
- Definitionen von erweiterten und zusammengesetzten Datentypen
- Restriktionen (Constraints), d.h. Gültigkeitsbereiche von Datentypen

{Hier wird eine kurze Übersicht zu __WSDL__ (\url{https://de.wikipedia.org/wiki/Web_Services_Description_Language}) und __XSD__ eingeschoben. Eine ausführlichere Beschreibung zum Thema `Webservices` ist im Anhang zu finden. 

WSDL ist eine Sprache zur Beschreibung von Netzwerkdiensten (Webservices). Die Sprache ist unabhängig von Plattform, Programmiersprache und Protokoll. Die beschriebenen Dienste tauschen Nachrichten auf der Basis von XML aus. WSDL beschreibt die angebotenen Funktionen, Daten, Datentypen und Austauschprotokolle eines Webservices. Es werden die Operationen definiert, welche von aussen zugänglich sind, sowie die Parameter und Rückgabewerte dieser Operationen. WSDL enthält funktionale Angaben zu

- der Schnittstelle
- dem Zugangsprotokoll und Details zum Deployment
- zu allen notwendigen Informationen für den Zugriff auf den Service. 

Beschreibungselemente sind:

- __types__
- __message__
- __portType__
- __binding__
- __port__
- __service__

XSD steht für XML Schema Definition und ist eine von W3C empfohlene Definition von Strukturen für XML-Dokumente. 
}

\pagebreak

Die folgende Tabelle gibt eine Übersicht über den Inhalt der angebotenen Definitionsdateien

+--------------------------------+-----------------------------------------------------------------------------+
|      Dateinamen, Schema Namen  |  Beschreibung                                                               |
+================================+=============================================================================+
|                         *.XSD  |  XML Schema Dateien, welche die Definitionen der ICAR ADE XML               |
|                                |  Datenstrukturen enthalten                                                  |
+--------------------------------+-----------------------------------------------------------------------------+
|                    ICAR_*.XSD  |  Definitionen von Datenelementen, welche von der ICAR ADE Grupppe erstellt  |
|                                |  wurden                                                                     |
+--------------------------------+-----------------------------------------------------------------------------+
|                     ISO_*.XSD  |  Definitionen von Datenelementen, welche vom ISO Standard abgeleitet wurden |
+--------------------------------+-----------------------------------------------------------------------------+
|                   UNECE_*.XSD  |  XSD Dateien, welche vom UNCEFACT Projekt zur Verfügung gestellt werden     |
|                                |  siehe unter http://www.unece.org/cefact/xml_schemas/index.html             |
+--------------------------------+-----------------------------------------------------------------------------+
|  UnqualifiedDataType_13p0.XSD  |  XSD Datei, welche die Definition der unqualifizierten UNCEFACT Datentypen  |
|                                |  enthalten. Diese Datentypen erweitern die Standard XSD Datentypen mit      |
|                                |  zusätzlichen Attributen. Diese werden in den ICAR und UNCEFACT             |
|                                |  Definitionen anstelle der Standard XSD-Typen verwendet.                    |
+--------------------------------+-----------------------------------------------------------------------------+
|                      *_CODE_*  |  XSD Datei mit Definitionen von Codes                                       |
+--------------------------------+-----------------------------------------------------------------------------+
|                  wsMrAde.wsdl  |  Beschreibung des ICAR ADE SOAP Dienstes. Diese definiert ein Set von       |
|                                |  Nachrichten-Paaren, welche alle aus einer Anfrage und einer Antwort        |
|                                |  bestehen                                                                   |
+--------------------------------+-----------------------------------------------------------------------------+
|                  ADE_v1p8.xsd  |  Hauptdatei (entry point) der Definitionen der Datenstrukturen des ICAR ADE |
+--------------------------------+-----------------------------------------------------------------------------+

In der ICAR ADE Spezifikation sind Definitionen von Daten und Protokollen durch die kommerzielle Software XMLSPY von ALTOVA (http://www.altova.com/documents/XMLSpyPro.pdf) illustriert. Als Beispiel wurde für den Dienst ``GetHerdListRequest'' folgendes Diagramm erstellt

```{r echo=FALSE, results='asis'}
rqudocuhelper::insertOdgAsPdf(psOdgFileStem = "GetHerdListRequestDiagram")
```

Die in den Diagrammen verwendeten Symbolen haben folgende Bedeutung

```{r echo=FALSE, results='asis'}
rqudocuhelper::insertOdgAsPdf(psOdgFileStem = "XMLSpyDiagSymbol")
```


```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("### Alternative Transport Protokolle")
```
Abgesehen von SOAP gibt es andere internationale Transport Protokolle. Als Beispiel gibt es den ISO-Standard  ADIS/ADED, welcher in ISO 17532(2007) beschrieben wurde. {Diese Standards wurden offenbar in [ISOagriNET](http://www.isoagrinet.org/) verwendet. ADIS ist eine Datenbeschreibungssprache und ADED ist ein Daten-Dictionary.} 

Bei den Transportprotokollen hat REST basierend auf dem HTTP unter Verwendung von XML, Jason {müsste eingentlich JSON heissen} und anderen Technologien zum Datentransport eine grössere Verbreitung gefunden.

Der Einfachheit halber fokussiert die ICAR Spezifikation zuerst auf SOAP/XML. Die Integration von alternativen Protokollen wird auf später verschoben.

```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("### ICAR Typen und Codeliste")
```
Alle Datenelemente, welche durch die ICAR ADE Spezifikation erzeugt wurden können innerhalb der WSDL/XSD Dateien durch den Präfix ``icar:'' erkannt werden. Alle Datenelemente basieren auf UNCEFACT Datentypen. Eine Beschreibung dieser Datenelemente ist in den nachfolgenden Abschnitten gegeben.

```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("### Externe Datenelemente")
```
Das Ziel des ICAR ADE Standards ist es, wo immer möglich auf andere schon vorhandene Standards von ISO, IANA oder UNCEFACT abzustützen. 

**UNCEFACT Daten Typen**

Die WSDL/XSD Definitionen von ICAR ADE verwenden die UNCEFACT Basisdatentypen. Die UNCEFACT Datentypen basieren auf den XSD Basistypen, wobei die XSD Typen durch zusätzliche Attribute und Restriktionen erweitert wurden. Diese sind in der Datei ``UnqualifiedDataType_13p0.xsd'' definiert. Diese Datentypen sind  mit dem Präfix ``udt:'' gekennzeichnet.

Die folgenden UNCEFACT Typen werden verwendet um die Typen einer Dateneinheit (data item) zu definieren.

+------------------------+--------------------------+-------------------+-----------+
|  Name                  |  Beschreibung            |  Kommentar        |  XSD Typ  |
+========================+==========================+===================+===========+
|  udt:CodeType          |  Zeichenkette (String)   |  Code verweist    |  String   |
|                        |  welche verwendet wird   |  auf Aufzählung   |           |
|                        |  einen Wert              |                   |           |
|                        |  darzustellen oder zu    |                   |           |
|                        |  ersetzen                |                   |           |
+------------------------+--------------------------+-------------------+-----------+
|  udt:DateType          |  spezifisches Datum      |  Repräsentation   |  String   |
|                        |  auf der Zeitachse       |  welche aufgrund  |           |
|                        |                          |  des Transport    |           |
|                        |                          |  Protokolls       |           |
|                        |                          |  definiert sind   |           |
+------------------------+--------------------------+-------------------+-----------+
|  udt:DateTimeType      |  spezifischer Zeitpunkt  |  Repräsentation   |  String   |
|                        |  auf der Zeitachse       |  welche aufgrund  |           |
|                        |                          |  des Transport    |           |
|                        |                          |  Protokolls       |           |
|                        |                          |  definiert sind   |           |
+------------------------+--------------------------+-------------------+-----------+
|  udt:IDType            |  String für eindeutige   |                   |  String   |
|                        |  Identifikation einer    |                   |           |
|                        |  Objektinstanz           |                   |           |
+------------------------+--------------------------+-------------------+-----------+
|  udt:MeasureType       |  Numerischer Wert        |  Messungen sind   |  Dezimal  |
|                        |  bestimmt durch die      |  mit einer        |           |
|                        |  Messung eines Objektes  |  Einheit versehen |           |
|                        |                          |  eine Auflösung   |           |
|                        |                          |  und falls nötig  |           |
|                        |                          |  ein Bereich mit  |           |
|                        |                          |  Minimum und      |           |
|                        |                          |  Maximum          |           |
+------------------------+--------------------------+-------------------+-----------+
|  udt:NameType          |  Wort zur Bezeichnung    |                   |  String   |                  
|                        |  einer Person, eines     |                   |           |
|                        |  Ortes einer Sache oder  |                   |           |
|                        |  eines Konzeptes         |                   |           |
+------------------------+--------------------------+-------------------+-----------+
|  udt:BinaryObjectType  |  Base64 codierte         |  z.Bsp. für zip   |  String   |
|                        |  binäre Daten            |  komprimierte     |           |
|                        |                          |  Daten verwendet  |           |
+------------------------+--------------------------+-------------------+-----------+
|  udt:TextType          |  Genereller Typ für Text |                   |  String   |
+------------------------+--------------------------+-------------------+-----------+
|  udt:IndicatorType     |  Boolsche Variable oder  |                   |  Boolean  |
|                        |  wahr oder falsch        |                   |           |
+------------------------+--------------------------+-------------------+-----------+


**UNCEFACT Codierung**

+-----------------------------+---------------------------------------------------------------------------+
|  Codierung                  |  Beschreibung                                                             |
+=============================+===========================================================================+
|  AgencyIdentificationCode   |  Liste von Organisation verantwortlich für die Betreuung von Codierungen  |
|                             |  welche als Wert des Attributs 'listAgencyID' im UNCEFACT Datentyp        |
|                             |  udt:CodeType verwendet werden                                            |
+-----------------------------+---------------------------------------------------------------------------+
|  CharacterSetEndcodingCode  |  Liste von Zeichencodierungen, welche als Werte für Attribute             |
|                             |  'encodingCode' im UNCEFACT Datentyp xsd:base64Binary verwendet werden    |
+-----------------------------+---------------------------------------------------------------------------+
|  MeasurementUnitCommonCode  |  Set von Einheiten, welche als Werte für das Attribut 'unitCode' im       |
|                             |  UNCEFACT Datentyp udt:MeasureType verwendet werden.                      |
+-----------------------------+---------------------------------------------------------------------------+


**ISO Codierung**

+-----------------------------+----------------------------+
|  Codierung                  |  Beschreibung              |
+=============================+============================+
|  ISO3AlphaCurrencyCode      |  Währungscode              |
+-----------------------------+----------------------------+
|  ISOTwoletterCountryCode    |  Zweistelliger Ländercode  |
+-----------------------------+----------------------------+


**IANA Codierung**

+-----------------------------+-----------------------------------+
|  Codierung                  |  Beschreibung                     |
+=============================+===================================+
|  CharacterSetCode           |  IANA Zeichencodierung            |
+-----------------------------+-----------------------------------+
|  MiMEMediaType              |  Liste von IANA MIME Media Typen  |
+-----------------------------+-----------------------------------+


```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("## Datenaustausch")
robjSecEnum$displayNumSection("### Austauschparameter")
```
Die Ausrüstung sollte für den Operator ein Interface anbieten, über welches folgende Austauschparameter abgefragt werden können. Für eine bestimmte Diestleistung geht es dabei um folgende Parameter:

* Url des Dienstleisters
* Information zur Authentifizierung (Benutzername/Passwort)
* Identifikation/Name/Land des Senders und des Empfängers
* Typ des Ortes (location) {Hier ist nicht klar, was mit Ort gemeint ist}
* Typ der Identifikation des Ortes
* Identifikation/Name/Land des Ortes
* Typ der primären und sekundären Tieridentifikation
* Weitere Hersteller-spezifische Parameter

Für einen bestimmten Dienstleister sollten die ausgetauschten Parameter gleich sein über alle angebotenen Dienstleisungen. 


```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("## Zugang zur Dienstleistung")
```
Da die Services nicht permanent verfügbar sind, sollte keine Anfrage geschickt werden, bevor nicht die folgenden Voraussetzungen überprüft sind

* Zugang zum Netzwerk
* Zugang zum Server des Dienstleisters
* Zugang zum Service selber

```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("### Datenübertragung")
```
Neue Daten sollten sobald als möglich verarbeitet werden. Solange Daten beim Dienstleister noch nicht verarbeitet werden konnten, soll der Client keine neuen Daten senden. Bei asynchroner Verarbeitung muss der Client auf eine Bestätigung (ticket) von Dienstleister warten.

Bestätigungen sollen nur zu vorgegebenen Zeiten an das Informationssystem geschickt werden. {Diese Aussage ist mir nicht klar. Entweder steht diese einfach isoliert da und dann ist aber nicht klar, weshalb Bestätigungen an das Informationssystem geschickt werden. Aus dem Kontext des vorangegangenen Abschnitts schickt das Informationssystem des Dienstleisters Bestätigungen an den Client und nicht umgekehrt}

Meldungen oder Nachrichten (message), welche den syntaktischen Anforderungen nicht genügen, dürfen nicht gesendet werden.

Sobald Daten in einer Anfrage (request) integriert sind und von einer Antwort (response) beantwortet werden, sollen die Daten als gesendet betrachtet werden.

Dienstleister (Service providers) und Clients (consumers) sollten Datenupdates und Löschungen verarbeiten können. Der Dienstleister muss auch berücksichtigen, dass der Client die Updates als Neuerfassung von Daten deklariert, da der Client nicht wissen kann, welche Daten schon vorhanden sind. {Der Client kann die History der Operationen nicht wissen, deshalb macht die Operation des Updates aus Sicht des Clients keinen Sinn.}

Die Vorbereitung einer Anfrage (request) gemäss den gestellten Anforderungen (business requirements) sollte unabhängig von der Zusammenstellung einer Nachricht (message) deren Syntax von der gewählten Technologie (SOAP) abhängt, gemacht werden.

```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("### Verschlüsselung")
```
Die Datenübertragung soll verschlüsselt sein. Verschlüsselung wird hier nicht beschrieben. Datentransport soll über verschlüsselte Protokolle (HTTPS) erfolgen.

```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("### Komprimierung")
```
Zur Minimierung der Netzwerkauslastung sollen grosse Nachrichten komprimiert werden. Zur Verhinderung der Begrenzung der Kompression bei http wird ein spezifischer Kompressionsmechanismus (Siehe Abschnitt "Nachrichtendesign") entworfen.


```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("## Datenverarbeitung")
```
Dienste können in "real time" oder "verzögert" (time differed) angeboten werden. Antworten sollen innerhalb von wenigen Sekunden geschickt werden. Alle Requests und alle Antworten sollen von der Ausrüstung und vom Informationssystem gespeichert werden. Die Anforderungen für Updates auf der Datenbank kann sich zwischen Dienstleistern unterscheiden. Alle Anfrage, welche nicht konform sind zu den folgenden Bedingungen sollen nicht verarbeitet werden. Folgende Konformitätsbedingungen sollen berücksichtigt werden:

* korrekte Syntax
* korrekte Authentifizierung
* Gültigkeit der Bestätigung (ticket)


```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("## Verifizierung der Benutzerrechte")
```
Benutzerrechte für die angebotenen Dienste sollen mit üblichen Funktionalitäten, wie Authentifizierungs-Schlüssel oder Benutzernamen/Passwort sichergestellt werden.


```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("## Spezifizierung der Anfrage")
```
Jede Anfrage soll aus drei Teilen bestehen

1. Einzelner Message Header (siehe Einheit MessageHeader vom Typ ADEExchangedDocumentType im Abschnitt Datenbeschreibung). Der Sender einer Anfrage erstellt ein eineindeutige Nachrichten-ID (Typ ADEExchangedDocumentType.Identifier). Siehe "Best Praxis für MessageId Creation" weiter unten
2. Eine Standard-Abfrage (siehe StandardRequest)
3. Spezifischer Request, welcher entweder aus einem Ticket oder einer spezifischen Nachricht für einen bestimmten Dienst besteht oder eine gezippte spezifische Nachricht ist. 

```{r echo=FALSE, results='asis'}
rqudocuhelper::insertOdgAsPdf(psOdgFileStem = "OrgSpezDiagramm5")
```


```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("## Spezifizierung der Antwort")
```
Jede Antwort soll aus drei Teilen bestehen:

1. Nachrichten-Header
2. Standard Antwort
3. Spezifischen Antwort


```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("## \"Best Praxis\" für die Erstellung einer Nachrichten-Id")
```
{Das sollte wahrscheinlich "Best Practice" heissen}

Nachrichten-Ids von Clients und Dienstanbietern sollten global eindeutig sein, damit eine einfache Identifikation jeder Nachricht möglich ist. Dies vereinfacht die Rückverfolgbarkeit der Nachrichten und hilft bei der Fehlersuche.

Nachrichten-Ids sollten auf einer Kette von folgenden Bestandteilen bestehen

* eindeutige Hardware Kennung (z. Bsp. MAC-Adresse)
* eindeutige Software Kennung
* eindeutige Komponente, um Nachrichten, welche in hoher Frequenz erzeugt werden. Diese dynamische Komponente kann über einen Timestamp oder eine Sequence von Integerzahlen umgesetzt werden

Es existieren verschiedene Tools in verschiedenen Programmiersprachen zur Erzeugung solcher IDs. (Z. Bsp. Guid.NewGuid() in C# {oder in Java existiert die Klasse UUID in java.util. Siehe http://stackoverflow.com/questions/2982748/create-a-guid-in-java oder http://kodejava.org/how-do-i-generate-uuid-guid-in-java/})


```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("## Behandlung lokaler Anforderungen (local requirements)")
```
Der ICAR ADE Standardisierungs-Prozess kann nicht all lokalen Anforderungen berücksichtigen. In erster Linie soll eine gemeinsame Basis geschaffen werden.

"Lokal" steht hier stellvertretend für nationale Standards. Es soll aber möglich sein, lokale Erweiterungen basierend auf speziellen Abmachungen zwischen Clients und Dienstanbietern hinzuzufügen.

Erweiterungen, welche die bestehenden Spezifikationen erweitern können auf zwei Arten hinzugefügt werden

1. __Lokale Kodierungslisten__: Lokale Kodierungen für alle Einheiten des Typs __udt:CodeType__ für welche ICAR noch keine akzeptierte Kodierung anbietet
2. __Lokale zusätzliche Daten__: Liste von Schlüssel-Wert Paaren spezifische für eine Entität, welche für lokal benötigte Datenelemente verwendet werden.

Lokale Variationen sollten auf ein Minimum beschränkt werden, da diese der Bestrebung von ICAR entgegenlaufen einen globalen Standard zu etablieren. Lokale Unterschiede führen zu erhöhter Komplexität und zu zusätzlichen Kosten.

```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("### Lokale Kodierungen")
```
Lokale Kodierungen müssen für Elemente des Typs __udt:CodeType__ im lokalen Kontext geliefert werden, z.Bsp. Rassencodes. Kontrollen und Validierungen müssen in separaten Programmen umgesetzt werden. Die Sicherstellung der Gültigkeit liegt in der Verantwortung der Entwickler. 

Der Service __GetLocalCodeList__ soll den Herstellern die Pflege und die Integration von lokale Kodierungen erleichtern. (Siehe den Abschnitt "Technische Services" für mehr Details)

```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("### Zusätzliche lokale Daten")
```
Zusätzliche von der ICAR Nachrichten-Spezifikation nicht vorgesehene Daten können über die Erweiterung __LocalAdditionalData__ hinzugefügt werden. Dabei handelt es sich um Code/wert-Paare vom Typ udt:textType. Die Überprüfung der Korrektheit der Daten liegt in der Verantwortung der Entwickler oder Dienstanbieter. Die ICAR wsdl/xsd Definitionen können nur die XML Struktur überprüfen nicht aber den Inhalt.

```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("## Gemeinsame Komponenten")
```
Dieser Abschnitt beschreibt die Komponenten, welche von allen Services verwendet werden, welche im Abschnitt "Beschreibung der Dienste" beschrieben werden.

```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("### ADEEXCHANGEDDOCUMENTTYPE")
```
Die Komponente (entity) __ADEExchangedDocumentType__ beinhaltet Informationen zu generellen Aspekten der Nachricht. Diese wird vom Datenelement __MessageHeader__ verwendet. Das nachfolgende Diagram stellt die Komponente schematisch dar.

```{r AdeExchangedDocumentTypeDiagram}
rqudocuhelper::insertOdgAsPdf(psOdgFileStem = "ADEExchangedDocumentType")
```

__ADEExchangedDocumentType__ enthält folgende Bestandteile:

* __Identifier__: Eindeutige Identität der Nachricht, welche durch den Sender vergeben wird
* __Issueing__: Datum und Uhrzeit, zu welcher die Nachricht abgesetzt wurde
* __Version__: Versionsnummer der Nachricht
* __Language__: Sprache, welche in der Nachricht verwendet wurde
* __LocalAdditionalData__: Liste aus Schlüssel- und Wert-Paaren, welche in einem lokalen Kontext verwendet werden, wie unter "Gemeinsamen Komponenten - Lokale Anpassungen" beschrieben sind
* __SenderParty__: Organisation oder Person verantwortlich für den Inhalt der Nachricht, kein Server-Identifier
* __RecipientParty__: Organisation oder Persion verantwortlich für die Verarbeitung der Nachricht, kein Server-Identifier


```{r AdePartyTypeHeader}
robjSecEnum$displayNumSection("### ADEPARTYTYPE")
```
Die Komponente __ADEPartyType__ beinhaltet den Namen und die Identität der Partei, welcher entweder Sender oder Empfänger der Nachricht sein kann. Diese Komponente wird verwendet von __SenderParty__ und __RecipientParty__. Im nachfolgenden Diagramm ist die Komponente AdePartyType dargestellt

```{r AdePartyTypeDiagram}
rqudocuhelper::insertOdgAsPdf(psOdgFileStem = "AdePartyType")
```

AdePartyType enthält folgende Bestandteile

* __Name__: Name der spezifizierten Partei (Sender oder Empfänger). {Im Original ist hier auch Identity angegeben}
* __ID__: Identität der spezifizierten Partei (Sender oder Empfänger)
* __Country__: Land der spezifischen Partei gemäss __ISOTwoletterCountryCodeIdentifierContent__


```{r StandardRequestTypeHeader}
robjSecEnum$displayNumSection("### STANDARDREQUESTTYPE")
```
Die Komponente __StandardRequestType__ repräsentiert den Standardinhalt einer Anfrage. Zwei verschiedene Typen von Authentifizierungen sind möglich, entweder Token-basierte oder Benutzernamen/Passwort basierte. Die Komponente wird vom Datenelement __StandardRequest__ verwendet.

```{r StandardRequestDiagram}
rqudocuhelper::insertOdgAsPdf(psOdgFileStem = "StandardRequest")
```

__StandardRequestType__ enhält folgende Bestandteile

* __AuthenticationToken__: Code zur Verifizierung der Benutzer-Identität und seiner Berechtigung einen Dienst zu verwenden
* __AuthentificationLogin__: Paar aus __Benutzername__ und __Passwort__


```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("### STANDARDRESPONSETYPE")
```
Die Komponente __StandardResponseType__ stellt den Inhalt einer Antwort dar. Dieser Type wird vom Datenelement __StandardResponse__ verwendet.

```{r StandardResponseDiagram}
rqudocuhelper::insertOdgAsPdf(psOdgFileStem = "StandardResponse")
```

Bestandteile von __StandardResponseType__:

* __RequestProcessingStatus__: Status der Anfragenverarbeitung, welcher vom Server zurückkommt, gemäss der Codierungsliste __RequestProcessingStatusCode__
* __RequestID__: Kopie der Nachrichten ID in der Einheit __MessageHeader.Identifier__ der Anfrage
* __RequestProcessingError__: Falls während der Verarbeitung der Anfrage ein Fehler aufgetreten ist, dann wird eine Fehlerbeschreibung geliefert


```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("### ERRORTYPE")
```
__ErrorType__ beinhaltet die Art des Fehlers bei einer Anfrage. Dieser Typ wird vom Datenelement __RequestProcessingError__

```{r ErrorTypeDiagram}
rqudocuhelper::insertOdgAsPdf(psOdgFileStem = "ErrorType")
```

__ErrorType__ hat folgende Bestandteile:

* __ErrorId__: Identität des Fehlers, z.Bsp. Fehlertext oder lokaler Fehlercode
* __ErrorSeverity__:  Schweregrad (severity) des Fehlers gemäss der Codierungsliste __ErrorSeverityCode__
* __ErrorDescription__: Beschreibung des Fehlers


```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("### TICKETRESPONSETYPE")
```
Der Typ __TicketResponseType__ repräsentiert ein Ticket, welches verwendet wird um eine Antwort zu bekommen. Dies wird bei der asynchronen Verarbeitung benötigt. Dieser Type wird von __SpecificRequest__ und __SpecificResponse__ vom Datenelement __TicketResponse__ verwendet


```{r TicketResponseDiagram}
rqudocuhelper::insertOdgAsPdf(psOdgFileStem = "TicketResponse")
```

Bestandteile von __TicketResponseType__

* __TicketID__: Identität der zu erhaltenden Antwort
* __NotBefore__: Datum/Zeit zu welcher Antwort verfügbar sein sollte


```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("### ZIPMESSAGETYPE")
```
__ZipMessageType__ ist ein Wrapper fuer den Transport von komprimierten Daten

```{r ZipMessageDiagram}
rqudocuhelper::insertOdgAsPdf(psOdgFileStem = "ZipMessage")
```

Bestandteile von __ZipMessageType__

* __ZIPMessage__: zip komprimierte Daten


```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("### LOCALADDITIONALDATATYPE")
```
Der Typ __LocalAdditionalDataType__ ist ein Container für Paare von Codes und Werten für lokale Daten ausserhalb des Gülitgkeitsbereichs der ICAR Spezifikation. Es wird verwendet durch __LocalAdditionalData__

```{r LocalAdditionalDataDiagram}
rqudocuhelper::insertOdgAsPdf(psOdgFileStem = "LocalAdditionalData")
```

Bestandteile 

* __AdditionalDataCode__: Name des Code-Werte-Paares
* __AdditionalDataValue__: Wert des Code-Werte-Paares
* __AdditionalDataComment__: Optionale Beschreibung der lokalen Daten-Entität


```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("### TIMEPERIODTYPE")
```
__TimePeriodType__ ist ein Wrapper für den Transport von Zeitpunkten (Beginn- und Endzeitpunkt)

```{r TimePeriodDiagram}
rqudocuhelper::insertOdgAsPdf(psOdgFileStem = "TimePeriod")
```

Bestandteile:

* __StartTime__: Beginn einer Zeitperiode
* __EndTime__: Ende einer Zeitperiode (optional)


\pagebreak

```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("# Beschreibung der Dienste (Service Description)")
```
{Die in diesem Abschnitt beschriebenen Dienste können in vier Gruppen eingeteilt werden. 

1. Melkvorgang 
2. Tierbewegungen
3. Reproduktion
4. Technische Dienste

Für den Austausch von Milchleistungsdaten sind vor allem die Dienste der ersten Gruppe relevant. Die Dienste rund um die Bewegungen der Tiere zwischen Standorten werden umgesetzt, um unterschiedliche Datenbestände zwischen ISMs und zentralen Datenbanken abzugleichen.


}
```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("## Melkvorgang (Milking)")
```

```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("### Gemeinsame Komponenten (Common Components)")
```

__MilkCharacteristicsType__

Die Komponente {Wahrscheinlich ist hier Datenkomponente gemeint} __Characteristics__ beinhaltet eine Liste von Characteristika eines Gemelks 

{Diese Formulierung macht so noch keinen Sinn. Vermutlich wird hier folgende Bedeutung impliziert: Characteristics steht für eine Sequenz oder eine Liste von MilkCharacteristicsTypen. Die MilkCharacteristicsTypen sind eine Art von generischen Datentypen oder Datenrecords, welche für jedwelche Art von Messungen verwendet werden können. Diese MilkCharacteristicsTypen bestehen aus zwei Komponenten. 

1. ein Messwert
2. ein Code, welcher den MilkCharacteristicsTypen referenziert.

__NB__: Was hier fehlt und was, z.Bsp. in den Data Dictionnaries der Melksystemanbieter vorkommt, ist die Angabe des Messzeitpunktes.} 

Ein Charakteristikum vom Typ __MilkCharacteristicsType__ wird als Synonym für ein Resultat einer Messung oder Klassierung von einer Milchprobe erhoben auf dem Hof oder im Labor. Dieser Typ kann auch zur Erfassung von Umweltbedingungen verwendet werden.

Das Charakteristikum wird durch einen eineindeutigen Code identifiziert, welcher auf die Definition nach der Codierungsliste "ICAR_MilkCharacteristicCode" referenziert. Eine bestimmte Anzahl solcher Definitionen ist von ICAR (Tabelle "Milk Characteristics Codes") vorgegeben. Diese Definitionen können aber auch durch lokale Charakteristika ergänzt werden.

```{r MilkCharacteristicsDiagram}
rqudocuhelper::insertOdgAsPdf(psOdgFileStem = "MilkCharacteristics")
```

Bestandteile:

* __MilkCharacteristicCode__: Obligatorischer Code, welcher das Charakteristikum identifiziert
* __MilkCharacteristicValue__: Messwert des Charakteristikums. Die Eigenschaft "__unitCode__" muss gemäss der Codierungstabelle "__Milk Characteristics Codes__" gesetzt sein

__MilkCharacteristicsLocalType__

Analog zu MilkCharacteristicsType ist dies ein Container für lokal verwendete Charakteristika, welche nicht im "ICAR Milk Characteristics Codes" aufgelistet sind. Komponenten sind

* __LocalMilkCharacteristicCode__: Identifikations-Code eines lokalen Milch-Charakteristikums. Die Codierungsliste muss lokal zur Verfügung gestellt werden.
* __MilkCharacteristicValue__: Messwert

```{r LocalMilkCharacteristicsDiagram}
rqudocuhelper::insertOdgAsPdf(psOdgFileStem = "LocalMilkCharacteristics")
```

```{r ServiceDescriptionUpdateMilkingResult}
robjSecEnum$displayNumSection("### Beschreibung des Dienstes UpdateMilkingResult")
```

{Die nun folgenden Beschreibungen von Anfragen und Antworten beginnen häufig mit dem Satz, dass eine entsprechende Nachricht, eine Anfrage oder eine Antwort konsistent sei mit der entsprechenden generellen Spezifikation. Da diese Aussage sehr oft wiederholt wird, wird diese im folgenden nicht immer wieder angefügt. Falls explizite Abweichungen von generellen Spezifikationen erwähnt sind, sind diese auch aufgeführt.}

__Zweck__

Dieser Dienst (Service) soll dem Eigentümer der Melkausrüstung erlauben, dass ein externes Informationssystem sich registriert für 

* Melkresultate {wahrscheinlich sind hier Milchleistungsdaten gemeint}
* Referenzen zwischen Tier-Identifikationen und Identifikationen von Milchproben

{Damit das externe Informationssystem Daten von der Melkausrüstung beziehen kann muss sich dieses zuerst beim Eigentümer der Melkausrüstung registrieren. Der hier beschriebene Service soll für diese Registration zuständig sein.}

__Beschreibung der Anfrage__

Diese Nachricht wird verwendet, um neue oder geänderte Daten von Melk-Ereignissen zum Dienstleister zu übermitteln

```{r UpdateMilkingResultRequestDiagram}
rqudocuhelper::insertOdgAsPdf(psOdgFileStem = "UpdateMilkingResultRequest")
```

{Dieses Diagramm wurde aus Auschnitten aus dem Original zusammengesetzt, damit es noch lesbar ist}


__AnimalMilkingResults__

beinhaltet die wesentlichen Eigenschaften für ein bestimmtes Gemelk (milking)

* __AnimalIdentity__ (Tier-Identität): Eindeutige Identität eines Tieres, welche für den Datentransfer verwendet wird. Diese Identität beinhaltet die Identität und den Label des gemolkenen Tieres. Die Identität kann zu einer Instanz vom Typ AnimalDetail verweisen. Diese enthält weitere Informationen zum Tier. Eine Instanz vom Typ AnimalDetail kann vom Service "__UpdateAnimal__" geliefert werden, falls diese erforderlich ist.

{Hier ist nicht klar, was mit Label gemeint ist. Bei der Datenübertragung ist es entscheidend, wer die Identität vergibt. Werden die Identitäten von jedem Betrieb vergeben, dann sind diese nur innerhalb des Betriebes eindeutig. Auf einem zentralen Informationssystem müssen die Betriebs-spezifischen Identitäten noch mit einer Betriebskennung ergänzt werden.}

* __Location__ (Melk-Ort): Orts-Id, wo Tier gemolken wurde. Diese Id kann auf eine Instanz von LiveStockLocation referenzieren, welche bei Bedarf vom Service __UpdateLiveStockLocation__ geliefert wird.

* __MilkingParlourUnit__, __MilkingBoxNumber__: optionale genauere Identifikation des Ortes, wo Tier gemolken wurde

* __MilkingStartingTime__, __MilkingDuration__, __MilkingVisitDuration__, __MilkingType__, __MilkingMilkWeight__, __MilkingSucces__: zusätzliche Beschreibung des Gemelks

* __Characteristics__: Sequenz/Liste von Milcheigenschaften (Milk characteristics), dies kann eine Messung oder eine Klassierung sein. Die einzelnen Elemente in der Sequenz/Liste sind Instanzen des Typs __MilkCharacteristics__. Prinzipiell ist es eine List von Schlüssel-Werte-Paaren, welche die Codes der MilkCharacteristic Typen mit den jeweiligen Messwerten verbindet. Die Definition der Codes ist in der Tabelle "Milk Characteristic Codes" gezeigt.

* __LocalCharacteristics__: Lokal definierte Variante von __Characteristics__. Ist nicht Teil der offiziellen "ICAR Milk Characteristics Codes"

* __QuarterMilking__: Optionale Viertel-Gemelks Resultate. Wird nicht von jedem Hersteller unterstützt. 

* __AnimalMilkingSample__: Optionale Instanz, welche Details von Milchproben für Laboranalysen beschreibt

* __MilkingDeviceID__: Optionaler Bestandteil, welcher die ID der Melkausrüstung enthält. Die ID ist eine Referenz auf die Entität Ausrüstung (Device), welche vom Service "__UpdateDevice__" geliefert wird, falls benötigt.

* __MeasureDeviceID__: Optionaler Bestandteil, welcher die ID des Messgerätes enthält. Die ID ist eine Referenz auf eine Entität Ausrüstung (Device), welche vom Service "__UpdateDevice__" geliefert wird, falls benötigt.

* __LocalAdditionalData__: Optionale Liste von Schlüssel-Wert Paaren, welche in einem lokalen Kontext verwendet werden.

{In der folgenden Darstellung sind die als nicht-optional deklarierten Komponenten einer AnimalMilkingResult Entität dargestellt. Mit Ausnahme der Entität Characteristics sind alles atomare Entitäten, d.h., diese haben keine weiteren Unterkomponenten.}

```{r AnimalMilkResultMandatory}
rmddochelper::insertOdgAsPdf(psOdgFileStem = "AnimalMilkResultMandatory")
```

__Characteristics__
Diese Entität beinhaltet die Gemelk-Eigenschaften, welche während eines Melkvorgangs aufgezeichnet werden. Diese sind im Abschnitt "Gemeinsame Komponenten" beschrieben.

__Beschreibung der Antwort__

Die Antwort __UpdateMilkingResultResponse__ dient zur Übermittlung und zum Empfang von Melk-Resultaten, wie sie vom Dienstleistungsanbieter verarbeitet werden.

```{r UpdateMilkingResultsResponse}
rmddochelper::insertOdgAsPdf(psOdgFileStem = "UpdateMilkingResultsResponse")
```

```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("### Dienstbeschreibung GetMilkingLabResults")
```

__Zweck__

Damit Betriebe Analyseresultate von externen Informationssystemen für Herdenmanagement oder Gerätekallibrierung bekommen können. Der Link zwischen Proben und den Analyseresultaten muss durch das Informationssystem der Aufzeichnungsorganisation (Serviceanbieter) zur Verfügung gestellt werden.

__Beschreibung der Anfrage__


```{r GetMilkingLabResultRequest}
rmddochelper::insertOdgAsPdf(psOdgFileStem = "GetMilkingLabResultRequest")
```

{Die im obigen Diagramm gezeigten Komponenten wurden schon einmal erkärt oder sind selbst-erklärend. Da dieser Service nicht in erster Priorität umgesetzt wird, verzichten wir auf eine weitere Beschreibung.}

__Beschreibung der Antwort__

{Die Antwort ist sehr ähnlich zu __AnimalMilkingSample__.}


```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("## Austausch von Tierdaten")
```
```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("### Anforderungen, Dienste und Nachrichten")
```
Eine korrekt geführte Liste aller Tiere in der Herde (im folgenden als Tierliste bezeichnet) ist eine Voraussetzung für eine zuverlässige Aufzeichnung von Tierdaten. Tierlisten auf der Melkausrüstung und auf dem Betriebs-Management-System (BMS) (farm management system) {dieser Begriff taucht hier zum ersten Mal auf und wurde nicht genauer definiert} weisen sehr wahrscheinlich Unterschiede auf. Gründe für solche Unterschiede sind

* Unterschiedliche Eingabe-Quellen (manuelle Eingabe durch Betriebsleiter, vs. automatisierte Registrierung)
* Unterschiedliche Verfügbarkeit der Daten

Der Business-Prozess `Austausch von Tierdaten` (Exchange of Animal Data) soll folgende Aufgaben erledigen:

* einfache Initialisierung der Datenbank auf der Melkausrüstung oder des Betriebs-Management-Systems
* Weiterleitung von neuen oder geänderten Daten auf das oder vom Betriebs-Management-System
* helfen Datenkonflikte früher festzustellen

Der Tierdatenaustausch stellt verschiedene Methoden zur Verfügung, welche helfen sollen die Daten auf der Melkausrüstung und im Betriebs-Managment-System synchron zu halten.

* __GetHerdList__: Initialisierung der Tierlisten auf dem IS der Melkausrüstrung oder auf dem BMS
* __GetAnimal__: Beschreibung des Tieres vom Dienstleister
* __UpdateAnimal__: Übermittlung der Tierbeschreibung and den Dienstleister
* __GetArrival__: Anfordern der Ankunftsänderungen (arrival changes) vom Dienstleister
* __UpdateArrival__: Übermitteln der Ankunftsänderungen an den Dienstleister
* __GetDeparture__: Anfordern der Abgangsänderungen (departure changes) vom Dienstleister
* __UpdateDeparture__: Übermitteln der Abgangsänderungen an den Dienstleister


```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("### Gemeinsame Komponenten")
```

__AnimalIdentityType__

Diese Entität kann offizielle oder alternative Tier-Identifikationen beinhalten. Als primäre Identitäten {analog zu primary keys auf der Datenbank} sollen nur offzielle Identitäten verwendet werden. Alternative Identitäten werden nur verwendet um Veränderungen von Namen oder Betriebs-internen Nummern zu erkennen. Auf dem IS der Melkausrüstung werden oft Betriebs-interne Nummern oder Namen verwendet, welche nicht eindeutig sein müssen und wieder verwendet werden. Die Verwendung solcher Betriebs-internen Identitäten können zu Fehlern bei der identifikation von Proben führen.

```{r AnimalIdentityType}
rmddochelper::insertOdgAsPdf(psOdgFileStem = "AnimalIdentityType")
```

{Die Bestandteile von AnimalIdentityType sind}

* __Identifier__: Alternative Tier-Identität {bei dieser Forulierung wird nicht klar, ob offizielle Tier-Identitäten auch mit diesem Typ repräsentiert werden}
* __Label__: Typ der alternativen Tier-Identität, gemäss der Codierungsliste __LabelCode__

\pagebreak

__AnimalCoreDataSetType__

Diese Entität beinhaltet die Kern-Charakteristika eines Tieres.

{Die folgenden Darstellungen sind aus der Originalgraphik zusammengesetzt}

```{r AnimalCoreDataSetType}
rmddochelper::insertOdgAsPdf(psOdgFileStem = "AnimalCoreDataSetType")
```

* __Identifier__: primäre eindeutige Identität des Tieres
* __AlternativeIdentity__: sekundäre Tieridentität
* __Specie__: Tier-Spezies
* __Gender__: Geschlecht
* __Birth__: Geburtsdatum des Tieres
* __Breed__: Lokaker Code der Rasse des Tieres
* __Sire__: Beschreibung des Vaters
* __RecipientDam__: Beschreibung der Trägermutter im Fall von ET
* __GeneticDam__: Beschreibung der genetischen Mutter

{Sire, RecipientDam und GeneticDam sind Instanzen von AnimalIdentityType}

\pagebreak

__ArrivalCoreDataSetType__

Diese Entität beschreibt den Zugang eines Tieres zu einem Standort (location) {damit ist wahrscheinlich ein Betrieb oder eine Herde gemeint}.

```{r ArrivalCoreDataSetType}
rmddochelper::insertOdgAsPdf(psOdgFileStem = "ArrivalCoreDataSetType")
```

{Die einzelnen Komponenten sind wie folgt definiert}

* __ArrivalDate__: Datum des Zugangs
* __ArrivalReason__: lokaler Code, welcher den Grund für Zugang
* __OriginLocation__: vorangegangener Standort, von welchem aus das Tier zugegangen ist
* __LocalAdditionalData__: lokal definierte Liste von Schlüssel-Wert-Paaren

\pagebreak

__DepartureCoreDataSetType__

Diese Entität beschreibt den Abgang eines Tieres von einem Standort.

```{r DepartureCoreDataSetType}
rmddochelper::insertOdgAsPdf(psOdgFileStem = "DepartureCoreDataSetType")
```

{Die einzelnen Komponenten sind wie folgt definiert}

* __DepartureDate__: Abgangsdatum eines Tieres von einem Standort
* __DepartureReasonCode__: Code, welcher den Abgangsgrund spezifiziert
* __DestinationLocation__: zukünftiger Standort zu welchem Tier verschoben wird
* __LocalAdditionalData__: lokal definierte Liste von Schlüssel-Wert-Paaren

\pagebreak

__AnimalDescriptionType__

Diese Komponente enthält die Beschreibung eines Tieres, aktuell sind darin Kern-Daten (core data), erweiterte Daten (extended Data) und Bewegungsdaten (movement data) enthalten. 

```{r AnimalDescriptionType}
rmddochelper::insertOdgAsPdf(psOdgFileStem = "AnimalDescriptionType")
```

{Dieser Datentyp ist aus vorher definierten Komponenten zusammengesetzt. Die einzelnen Komponenten sind wie folgt definiert.}

* __AnimalCoreDataSet__: Beschreibung eines Tieres
* __AnimalExtendedDataSet__: ist zusammengesetzt aus folgenden optionalen Elementen
    + __LastLocalization__: Datum des letzten Zugangs des Tieres zum Standort
    + __LastParturition__: letzte aufgezeichnete Trächtigkeit des Tieres
    + __LastInsemination__:  letzte aufgezeichnete Besamung des Tieres
* __AnimalMovementDataSet__: Liste von Bewegungen {zwischen Standorten} des Tieres
    + __Location__: Standort, wo Tier registriert wurde
    + __Arrival__: Zugang auf einen bestimmten Standort
    + __Departure__: Abgang von einem Standort

\pagebreak

__MovementRequest__

Die Entität MovementRequest dient dazu optionale Parameter, welche die Grösse des Resultats einer Bewegungsantwort (movement response) bestimmen. Als Beispiel wird diese Entität in den Nachrichten __GetArrival__ und __GetDeparture__ verwendet. {Aus dieser Formulierung wird die Bedeutung der Entität nicht klar. Offenbar ist das einfach die Datenstruktur, welche bei den genannten Services __GetArrival__ und __GetDeparture__ zurückgeliefert wird.}

```{r MovementRequest}
rmddochelper::insertOdgAsPdf(psOdgFileStem = "MovementRequest")
```

{Die im Diagramm gezeigten Komponenten sind wie folgt definiert.}

* __EventTimePeriod__: Ablaufdatum der Antwort auf eine gegebene Periode eines Zugangsereignisses (siehe TimePeriodType)
* __RegistrationTimePeriod__: Ablaufdatum der Antwort einer gegebenen Periode einer Zugangsregistrierung
* __Location__: Standort, falls dieser gegeben, dann werden Antworten auf diese Standort beschränkt
* __AnimalIdentifier__: Tier-Identität, falls diese gegeben, dann wird Antwort auf dieses Tier beschränkt


```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("### Servicebeschreigung: GetHerdList")
```

__Zweck__

Erlaubt es dem Besitzer der Melkanlage eine Tierliste zu bekommen, inklusive Bewegungsdaten, Reproduktionsdaten wie z. Bsp. die letzte Abkalbung oder die letzte Besamung. Die Resultate können durch die Angabe von Suchparametern, wie Standort, Geschlecht oder Zeitperiode eingegrenzt werden.


__Anfragebeschreibung__

Die Nachricht __GetHerdListRequest__ wird verwendet für Anfragen nach einer Herdenliste {Liste aller Tiere in einer Herde} für einen bestimmten Standort im BMS. 

```{r GetHerdListRequest}
rmddochelper::insertOdgAsPdf(psOdgFileStem = "GetHerdListRequest")
```

Die Eingrenzung des Resultats wird über optionale Parameter gemacht.

```{r HerdListRequest}
rmddochelper::insertOdgAsPdf(psOdgFileStem = "HerdListRequest")
```

{Die Komponenten sind wie folgt definiert}

* __Gender__: Resultate werden auf ein bestimmtes Geschlecht beschränkt
* __Periode__: Beschränkung der Resultate auf eine bestimmte Zeitperiode
* __Location__: Beschränkung der Resultate auf einen Standort

\pagebreak

__Antwortbeschreibung__


```{r GetHerdListResponse}
rmddochelper::insertOdgAsPdf(psOdgFileStem = "GetHerdListResponse")
```

Der Container __HerdListMessage__ beinhaltet die Beschreibung des Standorts (Location) und eine Liste von Tierbeschreibungen {im Container} __HerdListAnimalDescription__ vom Typ AnimalDescription. 


```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("### Servicebeschreigung: UpdateHerdList")
```

__Zweck__

Erlaubt dem Eigentümer der Melkanlage Änderungen in der Herdenliste, inklusive Bewegungsdaten und Reproduktionsdaten an den Dienstleister zu übermitteln.


__Anfragebeschreibung__

Die Nachricht __UpdateHerdListRequest__ ist konsisten mit den allgemeinen Spezifikationen für Anfragen. 

Der Container __HerdListMessage__ beinhaltet eine Standortangabe (Location), eine Liste von Tierbeschreibungen, welche an den Dienstleister übermittelt werden sollen.

```{r UpdateHerdList}
rmddochelper::insertOdgAsPdf(psOdgFileStem = "UpdateHerdList")
```

__Antwortbeschreibung__

Die Nachricht __UpdateHerdListResponse__ wird verwendet um den Status der Verarbeitung der Herdenlistendaten durch den Dienstleister zu empfangen.

```{r UpdateHerdListResponse}
rmddochelper::insertOdgAsPdf(psOdgFileStem = "UpdateHerdListResponse")
```

```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("### Servicebeschreigung: GetAnimal")
```

__Zweck__

Der Dienst __GetAnimal__ ermöglicht es der Melkausrüstung Tierinformationen vom BMS zu erhalten

__Anfragebeschreibung__

Die Nachricht __GetAnimalRequest__ macht eine Anfrage für Tierinformationen, welche auf dem BMS gespeichert sind.

```{r GetAnimalRequest}
rmddochelper::insertOdgAsPdf(psOdgFileStem = "GetAnimalRequest")
```

__Antwortbeschreibung__

Die Nachricht __GetAnimalResponse__ enthält die Informationen des Tiers, welches durch den Parameter __AnimalIdentifier__ spezifiziert wird.

```{r GetAnimalResponse}
rmddochelper::insertOdgAsPdf(psOdgFileStem = "GetAnimalResponse")
```

__AnimalMessage__ enthält die Beschreibung des angeforderten Tieres.

```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("### Servicebeschreigung: UpdateAnimal")
```

__Zweck__

Der Dienst __UpdateAnimal__ erlaubt es der Melkausrüstung Informationen an das BMS zu schicken.

__Anfragebeschreibung__

```{r UpdateAnimal}
rmddochelper::insertOdgAsPdf(psOdgFileStem = "UpdateAnimal")
```

__AnimalListMessage__ entspricht einer Liste von __AnimalData__ {hier sollte es wahrscheinlich AnimalDetail heissen} Komponenten vom Typ __AnimalListMessageType__, welche die Details der Tiere, welche aktuell durch die Melkausrüstung verwaltet werden.


```{r AnimalDetail}
rmddochelper::insertOdgAsPdf(psOdgFileStem = "AnimalDetail")
```

* __AnimalCoreDataSet__: Beschreibung der zentralen Daten eines Tieres
* __AnimalMovementDataSet__: Liste von Standortänderungen, welche für die Melkausrüstung bekannt sind
* __Location__: Standort eines Tieres
* __ArrivalCoreDataSet__: zentrale Daten eines Zugangs zu einem Standort
* __DepartureCoreDataSet__: Details eines Abgangs eines Tieres von einem Standort

\pagebreak

__Antwortbeschreibung__

Nachricht __UpdateAnimalResponse__ wird verwendet den Verarbeitungsstatus  für Daten eines Tieres vom Dienstleister zu erhalten.

```{r UpdateAnimalResponse}
rmddochelper::insertOdgAsPdf(psOdgFileStem = "UpdateAnimalResponse")
```

```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("### Servicebeschreigung: GetArrivals")
```

__Zweck__

Der Service __GetArrivals__ erlaubt es dem Eigentümer der Ausrüstung Informationen über Zugänge eines Tieres zu einem bestimmten Standort zu erhalten.

__Anfragebeschreibung__

Die Nachricht __GetArrivalsRequest__ wird verwendet die Liste von Zugängen von Tieren, welche auf dem BMS gespeichert sind, zu erhalten.

```{r GetArrivalsRequest}
rmddochelper::insertOdgAsPdf(psOdgFileStem = "GetArrivalsRequest")
```

Das Resultat der Anfrage kann durch die Angabe weiterer Parameter in der Entität __MovementsRequest__ eingegrenzt werden. 

__Antwortbeschreibung__
Die Nachricht __GetArrivalsResponse__ gibt eine Liste von Zugangsdaten, welche auf dem BMS registriert sind und welche durch verschiedene Parameter eingeschränkt werden können.

```{r GetArrivalsResponse}
rmddochelper::insertOdgAsPdf(psOdgFileStem = "GetArrivalsResponse")
```

```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("### Servicebeschreigung: UpdateArrivals")
```

```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("### Servicebeschreigung: GetDepartures")
```


```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("### Servicebeschreigung: UpdateDepartures")
```


```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("## Austausch von Reproduktions-Ereignissen")
```


```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("## Technische Dienste")
```


\pagebreak

```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("# Datenverzeichnis")
```
Die `xsd`-Dateien gelten als primäres Datenverzeichnis. Beschreibungen von Datenelementen müssen in den `xsd`-Dateien mittels `xsd:document`-Elementen zur Verfügung gestellt werden. Der folgende Ausschnitt gibt eine Beispiel für eine solche Beschreibung

```{r XsdExample}
rmddochelper::insertOdgAsPdf(psOdgFileStem = "XsdExample")
```

Aus den `xsd`-Dateien können html-Seiten erzeugt werden.

\pagebreak
\appendix

```{r echo=FALSE,results='asis'}
robjSecEnum$displayNumSection("# Anhang")
robjSecEnum$displayNumSection("## Web Service")
```



